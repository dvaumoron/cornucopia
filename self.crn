
commonNames = [
    "Any", "Append", "Bool", "Byte", "Cap", "Chan", "Comment", "Comparable", "Complex", "Complex64", "Complex128", "Err", "Error",
    "Func", "Float32", "Float64", "Id", "Int", "Int8", "Int16", "Int32", "Int64","Imag", "Index", "Interface", "Iota", "Len",
    "Lit", "LitByte", "LitRune", "Make", "Map", "Nil", "Op", "Parens", "Qual", "Real", "Recover", "Rune", "String",
    "Uint","Uint8", "Uint16", "Uint32", "Uint64", "Uintptr", "Values",
]

globalNames = [
    "NewFile",  "Break", "Case", "Close", "Continue", "Copy", "Default", "Defer", "Delete", "Empty", "Fallthrough", "For", "Go",
    "Goto", "If", "Line", "List", "Null", "Return", "Select", "Switch", "Union", "Var",
]

jenStatementMethodNames = [
    "Add", "Assert", "Block", "Call", "Clone", "Defs", "Dot", "Else", "Params", "Range", "Struct", "Tag", "Types",
]

JEN = "github.com/dave/jennifer/jen"
STARLARK = "go.starlark.net/starlark"

def newFileWithComment():
    f = NewFile("main")
    f.HeaderComment("This file is generated - do not edit.")
    return f

def addGlobals(name):
    return Qual(STARLARK, "Universe").Index(name).Op("=").Qual(STARLARK, "NewBuiltin").Call(name, Id("wrapped" + name))

def newStarlarkBuiltinFunc(f, name, param, param2, param3, param4):
    return f.Func().Id(name).Params(
        Id(param).Op("*").Qual(STARLARK, "Thread"),
        Id(param2).Op("*").Qual(STARLARK, "Builtin"),
        Id(param3).Qual(STARLARK, "Tuple"),
        Id(param4).Index().Qual(STARLARK, "Tuple"),
    ).Parens(List(Qual(STARLARK, "Value"), Error()))

def returnWrappedStatement(value):
    return Return(Id("wrapper").Types(Op("*").Qual(JEN, "Statement")).Values({
            Id("inner"): value,
            Id("wType"): Op("&").Id("jenStatementWrappedType"),
    }), Nil())

def basicFunction(f, functionName):
    newStarlarkBuiltinFunc(f, "wrapped" + functionName, "_", "_", "_", "_").Block(
        returnWrappedStatement(Qual(JEN, functionName).Call()),
    )
    f.Line()

def basicMethod(f, typeName, methodName):
    newStarlarkBuiltinFunc(f,"jen" + typeName +"_" + methodName, "_", "b", "_", "_").Block(
        Id("recv").Op(":=").Id("b").Dot("Receiver").Call().Assert(Id("wrapper").Types(Op("*").Qual(JEN, typeName))),
        Id("stmt").Op(":=").Id("recv").Dot("inner").Dot(methodName).Call(),
        returnWrappedStatement(Id("stmt")),
    )
    f.Line()

def newMethod(typeName, name):
    return Qual(STARLARK, "NewBuiltin").Call(name, Id(typeName + "_" + name))

def registerType(name, methodNames):
    return Id(name+"WrappedType").Op("=").Id("makeWrappedType").Call(name, *[newMethod(name, methodName) for methodName in methodNames])

linking = newFileWithComment()

linking.Func().Id("init").Params().Block(
    registerType("jenFile", [
        "HeaderComment", "PackageComment",
        "Anon", "ImportAlias", "ImportName","ImportNames",
        "Comment", "Const", "Var", "Type", "Func", 
        "Line", "Save",
    ]),
    registerType("jenStatement", sorted(jenStatementMethodNames + commonNames)),
)

linking.Line()

linking.Func().Id("initCornucopiaGlobals").Params().Block(*[addGlobals(name) for name in sorted(globalNames + commonNames)])

linking.Save("linking.go")

wrapping = newFileWithComment()

basicFunction(wrapping, "Any")
basicFunction(wrapping, "Bool")
basicFunction(wrapping, "Break")
basicFunction(wrapping, "Byte")
basicFunction(wrapping, "Chan")
basicFunction(wrapping, "Comparable")
basicFunction(wrapping, "Complex64")
basicFunction(wrapping, "Complex128")
basicFunction(wrapping, "Continue")
basicFunction(wrapping, "Default")
basicFunction(wrapping, "Defer")
basicFunction(wrapping, "Empty")
basicFunction(wrapping, "Err")
basicFunction(wrapping, "Error")
basicFunction(wrapping, "Fallthrough")
basicFunction(wrapping, "Float32")
basicFunction(wrapping, "Float64")
basicFunction(wrapping, "Func")
basicFunction(wrapping, "Go")
basicFunction(wrapping, "Goto")
basicFunction(wrapping, "Int")
basicFunction(wrapping, "Int8")
basicFunction(wrapping, "Int16")
basicFunction(wrapping, "Int32")
basicFunction(wrapping, "Int64")
basicFunction(wrapping, "Iota")
basicFunction(wrapping, "Line")
basicFunction(wrapping, "Nil")
basicFunction(wrapping, "Null")
basicFunction(wrapping, "Recover")
basicFunction(wrapping, "Rune")
basicFunction(wrapping, "Select")
basicFunction(wrapping, "String")
basicFunction(wrapping, "Uint")
basicFunction(wrapping, "Uint8")
basicFunction(wrapping, "Uint16")
basicFunction(wrapping, "Uint32")
basicFunction(wrapping, "Uint64")
basicFunction(wrapping, "Uintptr")
basicFunction(wrapping, "Var")

basicMethod(wrapping, "File", "Const")
basicMethod(wrapping, "File", "Var")
basicMethod(wrapping, "File", "Type")
basicMethod(wrapping, "File", "Func")

basicMethod(wrapping, "Statement", "Any")
basicMethod(wrapping, "Statement", "Bool")
basicMethod(wrapping, "Statement", "Byte")
basicMethod(wrapping, "Statement", "Chan")
basicMethod(wrapping, "Statement", "Clone")
basicMethod(wrapping, "Statement", "Comparable")
basicMethod(wrapping, "Statement", "Complex64")
basicMethod(wrapping, "Statement", "Complex128")
basicMethod(wrapping, "Statement", "Else")
basicMethod(wrapping, "Statement", "Err")
basicMethod(wrapping, "Statement", "Error")
basicMethod(wrapping, "Statement", "Float32")
basicMethod(wrapping, "Statement", "Float64")
basicMethod(wrapping, "Statement", "Func")
basicMethod(wrapping, "Statement", "Iota")
basicMethod(wrapping, "Statement", "Int")
basicMethod(wrapping, "Statement", "Int8")
basicMethod(wrapping, "Statement", "Int16")
basicMethod(wrapping, "Statement", "Int32")
basicMethod(wrapping, "Statement", "Int64")
basicMethod(wrapping, "Statement", "Nil")
basicMethod(wrapping, "Statement", "Range")
basicMethod(wrapping, "Statement", "Recover")
basicMethod(wrapping, "Statement", "Rune")
basicMethod(wrapping, "Statement", "String")
basicMethod(wrapping, "Statement", "Uint")
basicMethod(wrapping, "Statement", "Uint8")
basicMethod(wrapping, "Statement", "Uint16")
basicMethod(wrapping, "Statement", "Uint32")
basicMethod(wrapping, "Statement", "Uint64")
basicMethod(wrapping, "Statement", "Uintptr")

wrapping.Save("wrapping.go")
